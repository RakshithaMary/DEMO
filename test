// Define recent months
WITH [i IN range(0, 2) | substring(toString(date() - duration({months: i})), 0, 7)] AS validMonths

// === CLIENT LEVEL ===
MATCH (agg:AggTx)-[:FOR_CLIENT]->(c:Client)
WHERE agg.monthId IN validMonths
WITH c.clientId AS clientId, sum(agg.totalAmount) AS Client_total, sum(agg.txCount) AS Client_tx
// === DEPOSIT PRODUCT LEVEL ===
OPTIONAL MATCH (agg:AggTx)-[:FOR_CLIENT]->(c2:Client {clientId: clientId})
MATCH (agg)-[:FOR_DEPOSIT_PRODUCT]->(dp:DepositProduct)
WHERE agg.monthId IN validMonths
WITH clientId, Client_total, Client_tx,
     sum(agg.totalAmount) AS Deposit_total, sum(agg.txCount) AS Deposit_tx
// === FLOW LEVEL ===
OPTIONAL MATCH (agg:AggTx)-[:FOR_CLIENT]->(c3:Client {clientId: clientId})
MATCH (agg)-[:FOR_DEPOSIT_PRODUCT]->(:DepositProduct)
MATCH (agg)-[:FOR_FLOW]->(:Flow)
WHERE agg.monthId IN validMonths
WITH clientId, Client_total, Client_tx, Deposit_total, Deposit_tx,
     sum(agg.totalAmount) AS Flow_total, sum(agg.txCount) AS Flow_tx
// === CHANNEL LEVEL ===
OPTIONAL MATCH (agg:AggTx)-[:FOR_CLIENT]->(c4:Client {clientId: clientId})
MATCH (agg)-[:FOR_DEPOSIT_PRODUCT]->(:DepositProduct)
MATCH (agg)-[:FOR_FLOW]->(:Flow)
MATCH (agg)-[:FOR_CHANNEL]->(:Channel)
WHERE agg.monthId IN validMonths
WITH clientId, Client_total, Client_tx, Deposit_total, Deposit_tx, Flow_total, Flow_tx,
     sum(agg.totalAmount) AS Channel_total, sum(agg.txCount) AS Channel_tx
// === PAYMENT PRODUCT LEVEL ===
OPTIONAL MATCH (agg:AggTx)-[:FOR_CLIENT]->(c5:Client {clientId: clientId})
MATCH (agg)-[:FOR_DEPOSIT_PRODUCT]->(:DepositProduct)
MATCH (agg)-[:FOR_FLOW]->(:Flow)
MATCH (agg)-[:FOR_CHANNEL]->(:Channel)
MATCH (agg)-[:FOR_PAYMENT_PRODUCT]->(:PaymentProduct)
WHERE agg.monthId IN validMonths
WITH clientId, Client_total, Client_tx, Deposit_total, Deposit_tx, Flow_total, Flow_tx, Channel_total, Channel_tx,
     sum(agg.totalAmount) AS PayProd_total, sum(agg.txCount) AS PayProd_tx
// === FINANCIAL INSTITUTION LEVEL ===
OPTIONAL MATCH (agg:AggTx)-[:FOR_CLIENT]->(c6:Client {clientId: clientId})
MATCH (agg)-[:FOR_DEPOSIT_PRODUCT]->(:DepositProduct)
MATCH (agg)-[:FOR_FLOW]->(:Flow)
MATCH (agg)-[:FOR_CHANNEL]->(:Channel)
MATCH (agg)-[:FOR_PAYMENT_PRODUCT]->(:PaymentProduct)
MATCH (agg)-[:FOR_FI]->(:FinancialInstitution)
WHERE agg.monthId IN validMonths
WITH clientId, Client_total, Client_tx, Deposit_total, Deposit_tx, Flow_total, Flow_tx, Channel_total, Channel_tx, PayProd_total, PayProd_tx,
     sum(agg.totalAmount) AS FI_total, sum(agg.txCount) AS FI_tx
// === PROSPECT LEVEL ===
OPTIONAL MATCH (agg:AggTx)-[:FOR_CLIENT]->(c7:Client {clientId: clientId})
MATCH (agg)-[:FOR_DEPOSIT_PRODUCT]->(:DepositProduct)
MATCH (agg)-[:FOR_FLOW]->(:Flow)
MATCH (agg)-[:FOR_CHANNEL]->(:Channel)
MATCH (agg)-[:FOR_PAYMENT_PRODUCT]->(:PaymentProduct)
MATCH (agg)-[:FOR_FI]->(:FinancialInstitution)
MATCH (agg)-[:FOR_PROSPECT]->(:Prospect)
WHERE agg.monthId IN validMonths

// --- existing matches and WITHs stay the same up to the Prospect level ---

RETURN
  clientId,
  round(Client_total, 2) AS Client_total,
  round(Deposit_total, 2) AS Deposit_total,
  round(Flow_total, 2) AS Flow_total,
  round(Channel_total, 2) AS Channel_total,
  round(PayProd_total, 2) AS PayProd_total,
  round(FI_total, 2) AS FI_total,
  round(sum(agg.totalAmount), 2) AS Prospect_total
WITH clientId, Client_total, Deposit_total, Flow_total, Channel_total, PayProd_total, FI_total, Prospect_total

// keep only those where any mismatch exists
WHERE
  apoc.coll.min([Client_total, Deposit_total, Flow_total, Channel_total, PayProd_total, FI_total, Prospect_total]) <>
  apoc.coll.max([Client_total, Deposit_total, Flow_total, Channel_total, PayProd_total, FI_total, Prospect_total])

RETURN *
ORDER BY clientId;

